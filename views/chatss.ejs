<%- include('partials/header') %>
        <div class="message">
             <button id="btn">All</button>
              <button id="btn">Unread</button>
               <button id="btn">Group</button>
                <button id="btn">Favorites</button>
        </div>
<div class="contact-list" id="contactList">
    <% if (contacts && contacts.length > 0) { %>
        <% contacts.forEach(contact => { %>
            <div class="contact-item" data-userid="<%=contact.contactId._id%>">
                <div class="contact-avatar"><%= contact.name.charAt(0) %></div>
                <div class="contact-info">
                    <div class="contact-name"><%= contact.name %></div>
                    <div class="contact-last-msg"><%= contact.phone %></div>
                     <div class="contact-last-message"><%= contact.lastMessage ? contact.lastMessage : '' %></div>
                    <div class="contact-about" style="display: none;"><%=contact.contactId.about%></div>
                </div>
                <% if (contact.unreadCount && contact.unreadCount > 0) { %>
                  <span class="unread-badge"><%= contact.unreadCount %></span>
                <% } %>
            </div>
        <% }) %>
    <% } %>
</div>
<div class="empty" id="emptyChatMsg" <% if (contacts && contacts.length > 0) { %>style="display:none"<% } %>>
    <div class="empty-chat-icon">
        <i class="fas fa-users"></i>
    </div>
    <p>No contacts yet</p>
</div>
    </div>
        <!-- Add this just before </body> -->
<div class="user-info-overlay" id="userInfoOverlay"></div>
<div class="user-info" id="userInfoSidebar">
  <div class="crossEdit">
    <div class="crossbtn">
    <i class="fa-solid fa-xmark"></i>
    </div>
    <div class="editbtn">
    <i class="fa-solid fa-pencil"></i>
    </div>
  </div>
  <div class="profile-avatar" id="profileAvatar"></div>
  <div class="profile-name" id="profileName"></div>
  <div class="profile-phone" id="profilePhone"></div>
  <div class="profile-about" id="profileAbout"></div>
</div>

   <%- include('partials/footer') %>
   <script src="/socket.io/socket.io.js"></script>
   <script>
    const socket = io();
    const contactMap = {};
    const onlineUserIds = new Set();
    let messagesSkip = 0;
    const messagesLimit = 30;
    let allMessagesLoaded = false;
    let isLoadingMessages = false;
    // --- Add unreadCounts object to track unread counts per contact ---
    const unreadCounts = {};

    async function getUserInfo() {
        const res = await fetch("/api/me", {
            method: "GET",
            credentials: "include",
        });

        const data = await res.json();
        if (data.user) {
            localStorage.setItem("userId", data.user._id);
            const userId = localStorage.getItem("userId")
            socket.emit("join",userId)
        }
    }

window.addEventListener("DOMContentLoaded", () => {
  getUserInfo();
  document.querySelectorAll(".contact-item").forEach(contact => {
    const userId = contact.dataset.userid;
    const name = contact.querySelector('.contact-name')?.textContent.trim() || "";
    const phone = contact.querySelector('.contact-last-msg')?.textContent.trim() || "";
    contactMap[userId] = { name, phone };
    // Initialize unreadCounts from DOM
    const badge = contact.querySelector('.unread-badge');
    unreadCounts[userId] = badge && badge.textContent ? parseInt(badge.textContent, 10) : 0;
    console.log("contact",contactMap);  
  });
  updateEmptyChatMessage();
});


    const personalChats = document.querySelectorAll(".contact-item");
    console.log(personalChats);

    personalChats.forEach(contact => {
        contact.addEventListener('click', async function () {
            const contactName = this.querySelector('.contact-name').textContent;
            const contactAvatar = this.querySelector('.contact-avatar').textContent;
            const contactPhone = this.querySelector('.contact-last-msg').textContent
            const contactabout = this.querySelector('.contact-about').textContent
            const userId = this.dataset.userid;
            window.currentReceiverId = userId;
            // --- Emit chat-open event to backend ---
            const myUserId = localStorage.getItem('userId');
            socket.emit('chat-open', { userId: myUserId, contactId: userId });

            const statusText = document.querySelector('.nav-info .user-status');
               if (statusText) {
                   if (onlineUserIds.has(userId)) {
                       statusText.innerText = "Online";
                       statusText.style.color = "green";
                   } else {
                       statusText.innerText = "Offline";
                       statusText.style.color = "gray";
                   }
               }

            document.querySelector('.nav-name').textContent = contactName;
            document.querySelector('.nav-avatar').textContent = contactAvatar;

            document.querySelector('.profile-name').textContent = contactName;
            document.querySelector('.profile-avatar').textContent = contactAvatar;
            document.querySelector('.profile-phone').textContent = contactPhone;
            document.querySelector('.profile-about').textContent = contactabout;

            document.querySelector('.empty-chat').style.display = 'none';
            document.querySelector('.chattingArea').style.display = 'block';

            document.getElementById('sidebar').classList.add('active');
            document.getElementById('chatArea').classList.add('active');
            
            messagesSkip = 0
            allMessagesLoaded = false;
            await loadChatMessages(false); // fetch real messages
            // --- Reset unread count for this contact when chat is opened ---
            unreadCounts[userId] = 0;
            updateUnreadBadge(userId, 0);
        });
    });


    const messageInput = document.querySelector('.message-input');
    messageInput.addEventListener('input', function() {
    const senderId = localStorage.getItem('userId');
    const receiverId = window.currentReceiverId;
    if (receiverId) {
        socket.emit('typing', { senderId, receiverId });
    }
});


// When loading messages, emit 'message-read' for all unread received messages
async function loadChatMessages(append = false) {
    if (isLoadingMessages || allMessagesLoaded) return;
    isLoadingMessages = true;
    document.getElementById('loader').style.display = 'block';
    await new Promise(resolve => setTimeout(resolve, 100));
    const senderId = localStorage.getItem("userId");
    const receiverId = window.currentReceiverId;
    const messagesContainer = document.getElementById('messagesContainer');
    if (!append) {
        messagesSkip = 0;
        allMessagesLoaded = false;
        messagesContainer.innerHTML = '';
    }
    try {
        const res = await fetch(`/api/messages/${receiverId}?skip=${messagesSkip}&limit=${messagesLimit}`, {
            method: 'GET',
            credentials: 'include'
        });
        const data = await res.json();
        console.log('messages',data)
        const oldScrollHeight = messagesContainer.scrollHeight;
        if (data.messages.length < messagesLimit) allMessagesLoaded = true;
        messagesSkip += data.messages.length;

        // Collect unread received message IDs
        const unreadReceivedIds = [];
        data.messages.forEach(msg => {
            const isSent = msg.senderId === senderId;
            if (!isSent && msg.status !== 'read' && msg._id) {
                unreadReceivedIds.push(msg._id);
            }
        });
        if (unreadReceivedIds.length > 0) {
            socket.emit('message-read', {
                messageIds: unreadReceivedIds,
                readerId: senderId,
                receiverId: window.currentReceiverId // <-- add this
            });
        }

        // Render messages
        data.messages.forEach(msg => {
            const messageDiv = document.createElement('div');
            const isSent = msg.senderId === senderId;
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            let tickHtml = '';
            if (isSent) {
              if (msg.status === 'sent') {
                tickHtml = '<span class="tick-icon">✔️</span>';
              } else if (msg.status === 'delivered') {
                tickHtml = '<span class="tick-icon">✔✔️</span>';
              } else if (msg.status === 'read') {
                tickHtml = '<span class="tick-icon" style="color: #34B7F1">✔✔️</span>';
              }
            }
            messageDiv.innerHTML = `
                ${msg.message}
                <div class="message-time">${formatTime(msg.timestamp)} ${tickHtml}</div>
            `;
            if (msg._id) messageDiv.dataset.messageId = msg._id;
            if (append) {
                messagesContainer.insertBefore(messageDiv, messagesContainer.firstChild);
            } else {
                messagesContainer.appendChild(messageDiv);
            }
        });

        if (!append) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        } else {
            messagesContainer.scrollTop = messagesContainer.scrollHeight - oldScrollHeight;
        }
    } catch (err) {
        console.error("Failed to load messages:", err);
    }
    isLoadingMessages = false;
    document.getElementById('loader').style.display = 'none'; 
}


const messagesContainer = document.getElementById('messagesContainer');
messagesContainer.addEventListener('scroll', function() {
    if (messagesContainer.scrollTop === 0 && !allMessagesLoaded && !isLoadingMessages) {
        loadChatMessages(true); // Load more and prepend
    }
});

    document.querySelector('.send-button').addEventListener('click', sendMessage);
    document.querySelector('.message-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });


   function moveContactToTop(userId) {
  const contactList = document.querySelector('.contact-list');
  const contactItem = contactList.querySelector(`.contact-item[data-userid="${userId}"]`);
  if (contactItem) {
    contactList.prepend(contactItem);
  }
}

    function sendMessage() {
        const input = document.querySelector('.message-input');
        const message = input.value.trim();
        const senderId = localStorage.getItem('userId');
        const receiverId = window.currentReceiverId;
        console.log('receiver',receiverId)

        if (!message) return;
        if (!receiverId) {
            alert("Select a user to chat with");
            return;
        }

        socket.emit('chat message', { senderId, receiverId, message });
        moveContactToTop(receiverId);

             input.value = '';
    }



    function updateEmptyChatMessage() {
    const contactList = document.querySelector('.contact-list');
    const emptyChatMsg = document.getElementById('emptyChatMsg');
    if (contactList && emptyChatMsg) {
        if (contactList.querySelectorAll('.contact-item').length === 0) {
            emptyChatMsg.style.display = '';
        } else {
            emptyChatMsg.style.display = 'none';
        }
    }
}


  socket.on("chat message", (msg) => {
  const senderId = localStorage.getItem("userId");
  const otherUserId = msg.senderId === senderId ? msg.receiverId : msg.senderId;
  moveContactToTop(otherUserId);

  // --- Update last message in contact list in real time ---
  const contactItem = document.querySelector(`.contact-item[data-userid="${otherUserId}"]`);
  if (contactItem) {
    const lastMsgDiv = contactItem.querySelector('.contact-last-message');
    if (lastMsgDiv) {
      lastMsgDiv.textContent = msg.message;
    }
  }

  
    if (!contactMap[otherUserId]) {
    const name = "Unknown";
    const phone = msg.senderPhone ? msg.senderPhone.replace(/\D/g, '').slice(-10) : "";

    contactMap[otherUserId] = { name, phone };


    async function unKnownUser(){
      const res = await fetch("/contacts/ajax/add", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, phone })
      });
    }
       unKnownUser()

     const emptyChat = document.querySelector('.empty');
    if (emptyChat) emptyChat.style.display = 'none';
    // Also show in your contact list UI
    const chatItem = document.createElement("div");
    chatItem.className = "contact-item";
    chatItem.dataset.userid = otherUserId;
        chatItem.innerHTML = `
            <div class="contact-avatar">?</div>
            <div class="contact-info">
                <div class="contact-name">Unknown</div>
                <div class="contact-last-msg">${msg.senderPhone}</div>
            </div>
        `;
    chatItem.addEventListener('click', async function () {
        document.querySelector('.nav-name').textContent = name;
        document.querySelector('.nav-avatar').textContent = name.charAt(0);
        window.currentReceiverId = otherUserId;

        document.querySelector('.empty-chat').style.display = 'none';
        document.querySelector('.chattingArea').style.display = 'block';

        document.getElementById('sidebar').classList.add('active');
        document.getElementById('chatArea').classList.add('active');

        await loadChatMessages();
    });
 
    document.querySelector(".contact-list").appendChild(chatItem);
    updateEmptyChatMessage();
  }


  // --- Unread badge logic for real-time updates ---
  // If this is a received message and the chat is NOT open, increment unread count
  if (msg.receiverId === senderId && window.currentReceiverId !== msg.senderId) {
    unreadCounts[msg.senderId] = (unreadCounts[msg.senderId] || 0) + 1;
    updateUnreadBadge(msg.senderId, unreadCounts[msg.senderId]);
  }

  if (
    (msg.senderId === window.currentReceiverId && msg.receiverId === senderId) ||
    (msg.senderId === senderId && msg.receiverId === window.currentReceiverId)
  ) {
    const messagesContainer = document.getElementById("messagesContainer");
    const messageDiv = document.createElement("div");
    const isSent = msg.senderId === senderId;
    messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
    let tickHtml = '';
    if (isSent) {
      if (msg.status === 'sent') {
        tickHtml = '<span class="tick-icon">✔️</span>';
      } else if (msg.status === 'delivered') {
        tickHtml = '<span class="tick-icon">✔✔️</span>';
      } else if (msg.status === 'read') {
        tickHtml = '<span class="tick-icon" style="color: #34B7F1">✔✔️</span>';
      }
    }
    messageDiv.innerHTML = `
      ${msg.message}
      <div class="message-time">${formatTime(msg.timestamp)} ${tickHtml}</div>
    `;
    if (msg._id) messageDiv.dataset.messageId = msg._id;
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    // If this is a received message and the chat is open, emit read immediately
    if (!isSent && msg.status !== 'read' && msg._id) {
      socket.emit('message-read', { messageIds: [msg._id], readerId: senderId ,receiverId:receiverId});
      // --- Reset unread count for this contact since chat is open ---
      unreadCounts[msg.senderId] = 0;
      updateUnreadBadge(msg.senderId, 0);
    }
  }
});

// Listen for message-delivered event to update tick to double tick in real time
socket.on('message-delivered', ({ messageId }) => {
  const messagesContainer = document.getElementById('messagesContainer');
  if (!messagesContainer) return;
  const msgDiv = messagesContainer.querySelector(`[data-message-id='${messageId}'] .message-time .tick-icon`);
  if (msgDiv) {
    msgDiv.innerHTML = '✔✔️';
    msgDiv.style.color = '';
  }
});

// Listen for message-read event to update ticks in UI
socket.on('message-read', ({ messageIds, readerId }) => {
  const messagesContainer = document.getElementById('messagesContainer');
  if (!messagesContainer) return;
  if (Array.isArray(messageIds)) {
    messageIds.forEach(id => {
      const msgDiv = messagesContainer.querySelector(`[data-message-id='${id}'] .message-time .tick-icon`);
      if (msgDiv) {
        msgDiv.innerHTML = '✔✔️';
        msgDiv.style.color = '#34B7F1';
      }
    });
  }
});

socket.on("user-online", (userId) => {
    onlineUserIds.add(userId);
    console.log("hijo")
    console.log(onlineUserIds)
    console.log("User online event received for:", userId);
    showOnlineDot(userId);
});
socket.on("user-offline", (userId) => {
    onlineUserIds.delete(userId);
    console.log("User offline event received for:", userId);
    showOfflineDot(userId);
});
socket.on("online-contacts", (onlineContactIds) => {
    // Clear and repopulate the onlineUserIds set
    onlineUserIds.clear();
    onlineContactIds.forEach(id => onlineUserIds.add(id));
    // Update status for all contacts in the list
    document.querySelectorAll('.contact-item').forEach(contact => {
        const uid = contact.dataset.userid;
        const statusText = contact.querySelector('.user-status');
        if (onlineUserIds.has(uid)) {
            if (statusText) {
                statusText.innerText = "Online";
                statusText.style.color = "green";
            }
        } else {
            if (statusText) {
                statusText.innerText = "Offline";
                statusText.style.color = "gray";
            }
        }
    });
    // Also update the chat header if a chat is open
    if (window.currentReceiverId) {
        const statusText = document.querySelector('.nav-info .user-status');
        if (statusText) {
            if (onlineUserIds.has(window.currentReceiverId)) {
                statusText.innerText = "Online";
                statusText.style.color = "green";
            } else {
                statusText.innerText = "Offline";
                statusText.style.color = "gray";
            }
        }
    }
});

// Listen for unread-counts and update badges on refresh
socket.on('unread-counts', (unreadCountsObj) => {
  Object.entries(unreadCountsObj).forEach(([userId, count]) => {
    unreadCounts[userId] = count; // update local state
    updateUnreadBadge(userId, count);
  });
});

socket.on('typing', (senderId) => {
    // Only show typing if this is the current chat
    if (window.currentReceiverId === senderId) {
        const statusText = document.querySelector('.nav-info .user-status');
        if (statusText) {
            statusText.innerText = "Typing...";
            statusText.style.color = "blue";
            // Optionally, revert to online/offline after a short delay
            clearTimeout(window.typingTimeout);
            window.typingTimeout = setTimeout(() => {
                if (onlineUserIds.has(senderId)) {
                    statusText.innerText = "Online";
                    statusText.style.color = "green";
                } else {
                    statusText.innerText = "Offline";
                    statusText.style.color = "gray";
                }
            }, 1500); // 1.5 seconds after last typing event
        }
    }
});

function showOnlineDot(userId) {
  // Update chat header if open
  if (window.currentReceiverId === userId) {
    const statusText = document.querySelector('.nav-info .user-status');
    console.log("receverId",window.currentReceiverId)
    console.log("Hello world" ,statusText)
    if (statusText) {
      statusText.innerText = "Online";
      statusText.style.color = "green";
    }
  }
}

function showOfflineDot(userId) {
  // Update chat header if open
  if (window.currentReceiverId === userId) {
    const statusText = document.querySelector('.nav-info .user-status');
    if (statusText) {
      statusText.innerText = "Offline";
      statusText.style.color = "gray";
    }
  }
}






    function getCurrentTime() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12 || 12;
        return `${hours}:${minutes} ${ampm}`;
    }

    function formatTime(timestamp) {
        const date = new Date(timestamp);
        let hours = date.getHours();
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12 || 12;
        return `${hours}:${minutes} ${ampm}`;
    }



             // Example: open sidebar when clicking nav-avatar
document.querySelector('.nav-avatar').addEventListener('click', function() {
  document.getElementById('userInfoOverlay').classList.add('active');
  gsap.to("#userInfoSidebar", { right: 0, duration: 0.4, ease: "power2.out" });
});

document.querySelector('.userinfo').addEventListener('click', function() {
  document.getElementById('userInfoOverlay').classList.add('active');
  gsap.to("#userInfoSidebar", { right: 0, duration: 0.4, ease: "power2.out" });
});

// Close sidebar with GSAP
document.getElementById('userInfoOverlay').addEventListener('click', function() {
  gsap.to("#userInfoSidebar", { right: -400, duration: 0.4, ease: "power2.in"});
  document.getElementById('userInfoOverlay').classList.remove('active');
});
// Close sidebar with GSAP
document.querySelector('.crossbtn').addEventListener('click', function() {
  gsap.to("#userInfoSidebar", { right: -400, duration: 0.4, ease: "power2.in"});
  document.getElementById('userInfoOverlay').classList.remove('active');
});

// search bar functionality

const input = document.getElementById('searchBar');
const resultBox = document.getElementById('contactList')
const emptyBox =  document.getElementById('emptyChatMsg')


input.addEventListener('input', async (e) => {
  const query = e.target.value;
    try {
    const res = await fetch(`/api/contacts/search?query=${encodeURIComponent(query)}`, {
      credentials: 'include' // if you're using cookies/auth
    });
    const data = await res.json();
    console.log('data',data)
    resultBox.innerHTML = '';
    data.forEach(contact => {
    const userId = contact.contactId 
   const newContact = document.createElement('div');
   newContact.className = 'contact-item';
   newContact.dataset.userid = userId;
   newContact.innerHTML = `
       <div class="contact-avatar">${contact.name.charAt(0)}</div>
       <div class="contact-info">
           <div class="contact-name">${contact.name}</div>
           <div class="contact-last-msg">${contact.phone}</div>
       </div>
   `;

      newContact.addEventListener('click', async function () {
       document.querySelector('.nav-name').textContent = contact.name;
       document.querySelector('.nav-avatar').textContent = contact.name.charAt(0);
       window.currentReceiverId = userId;
       document.querySelector('.empty-chat').style.display = 'none';
       document.querySelector('.chattingArea').style.display = 'block';
       document.getElementById('sidebar').classList.add('active');
       document.getElementById('chatArea').classList.add('active');
       messagesSkip = 0;
       allMessagesLoaded = false;
       await loadChatMessages(false);
       });
      resultBox.appendChild(newContact);

    });
 


  } catch (err) {
    console.error('Search failed', err);
  }
})

const style = document.createElement('style');
style.textContent = `
.unread-badge {
  display: inline-block;
  min-width: 10px;
  height: 25px;
  padding: 2px 7px;
  background: #25d366;
  color: #fff;
  border-radius: 50%;
  font-size: 0.85em;
  font-weight: bold;
  text-align: center;
  margin-left: 8px;
}
`;
document.head.appendChild(style);

function updateUnreadBadge(userId, count) {
  const contactItem = document.querySelector(`.contact-item[data-userid="${userId}"]`);
  if (!contactItem) return;
  let badge = contactItem.querySelector('.unread-badge');
  if (count > 0) {
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'unread-badge';
      contactItem.querySelector('.contact-info').appendChild(badge);
    }
    badge.textContent = count;
    badge.style.display = '';
  } else if (badge) {
    badge.style.display = 'none';
  }
}


</script>
